<?php 

// можно присваивать значение переменной, имя которой задается выражением
${"hello" . 2} = "Hi";  // переменная с именем $hello2


// -= Основы =-
// Переменные начинаются со знака доллара, имена чувствительны к регистру
// Правила для идентификаторов:
// Начинается с буквы или символа _
// Может состоять из букв, цифр и символов _ в любом количестве
// (буквы == символы a-z, A-Z, и байты от 127 до 255 (0x7f-0xff))

// Переменная $this -- особая переменная, которой нельзя ничего присваивать.
$my_var = "Hello!";
echo( $my_var );

// При присваивании, по-умолчанию происходит присваивание по значению.
// Также можно использовать присваивание по ссылке:
$foo = 'Боб';              // Присваивает $foo
$bar = &$foo;              // Ссылка на $foo через $bar.
$bar = "Меня зовут $bar";  // Изменение $bar...
echo $bar;
echo $foo;                 // меняет и $foo.

// нельзя взять ссылку от безымянного выражения:
// $bar = &(24 * 7);  // Ошибка

// неинициализированные переменные принимают значение в зависимости от их типа, который определеяется из контекста их первого использования
// так булевы принимают значение FALSE, целые и числа с плавающей точкой - ноль, строки (например, при использовании в echo) - пустую строку, а массивы становятся пустыми массивами.

// Неустановленная И не имеющая ссылок (т.е. без контекста использования) переменная; выведет NULL
var_dump($unset_var);

// Булевое применение; выведет 'false' (Подробнее по этому синтаксису смотрите раздел о тернарном операторе)
echo($unset_bool ? "true\n" : "false\n");

// Целочисленное использование; выведет 'int(25)'
$unset_int += 25; // 0 + 25 => 25

// для проверки инициализации можно использовать isset()
// (is_null() is an equivalent test to checking that isset() is false.)


// -= Предопределенные переменные =-
// Любому запускаемому скрипту PHP предоставляет большое количество предопределенных переменных. Однако многие из этих переменных не могут быть полностью задокументированы, поскольку они зависят от запускающего скрипт сервера, его версии и настроек, а также других факторов.

// Странное замечание: суперглобальные переменные не могут быть переменными переменных внутри функций или методов класса.

// перечень таких переменных: http://php.net/manual/ru/reserved.variables.php
// к ним относят, например: $GLOBALS, $_REQUEST, $_SESSION...


// -= Области видимости переменной =-
// Область видимости -- контекст, в котором переменная определена
// В большинстве случаем, переменные имеют одну область -- эта область охватывает также все include и require файлы

// функции ограничивают область видимости:
$a = 1; /* глобальная область видимости */ 

function test()
{ 
    echo $a; /* ссылка на переменную локальной области видимости */ 
} 

test(); // ничего не выведет

// в этом отличие PHP от, например, C
// для того, чтобы использовать глобальную переменную, нужно явно указать это с помощью ключевого слова global:
$a = 1;
$b = 2;

function Sum()
{
    global $a, $b;

    $b = $a + $b;
} 

Sum();
echo $b;    // int(3)

// кроме ключевого слова global, можно использовать предопределенный массив $GLOBALS:
function Sum2()
{
    $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];
}

// $GLOBALS существует в любой области видимости -- он суперглобальный (помимо того, что он предопределен).

// Использование статических переменных -- переменная существует только в локальной области видимости функции, но не теряет своего значения, когда выполнение программы выходит из этой области видимости
function test_static()
{
    static $a = 0;
    echo $a;
    $a++;
}

test_static();
test_static();
test_static();

// $a будет проинициализирована только при первом вызове функции, а каждый вызов функции test_static() будет выводить значение $a и инкрементировать его.

// статическим переменным можно присвоить выражение, но нельзя вызов функции (будет ошибка разбора)
function foo_static(){
    static $int = 1+2;        // можно
    static $int = sqrt(121);  // нельзя
}

// статические объявления вычисляются во время компилации

// global и static -- это ссылки на глобальные/стат-е переменные:
function test_global_ref() {
    global $obj;
    $obj = &new stdclass;
}

function test_global_noref() {
    global $obj;
    $obj = new stdclass;
}

test_global_ref();
var_dump($obj);         // NULL
test_global_noref();
var_dump($obj);         // object(stdClass)(0)


// -= Переменные переменных =-
// Переменная переменной берет значение переменной и рассматривает его как имя переменной
$a = 'hello';
$$a = 'world';

// hello использовано как имя переменной при помощи двух знаков доллара

// для взятия элементов из массива есть синтаксис со скобками:
// ${$a[1]} и ${$a}[1], например

// К свойствам класса также можно получить доступ динамически. Переменное имя свойства будет разрешено в том контексте, в котором произойдет вызов к нему. Например, в случае выражения $foo->$bar, локальная область видимости будет просканирована на наличие переменной $bar, значение которой будет использовано в качестве имени свойства объекта $foo. Это также работает и в том случае, если $bar осуществляет доступ к элементу массива.

// (!) Пожалуйста, обратите внимание, что переменные переменных не могут использоваться с Суперглобальными массивами PHP. Переменная $this также является особой, на нее нельзя ссылаться динамически.


// -= Переменные извне PHP =-
// Для получения данных формы можно использовать $_POST/$_GET или $_REQUEST:
echo $_POST['username'];
echo $_REQUEST['username'];

// Точки и пробелы в именах переменных преобразуется в знаки подчеркивания. Например, <input name="a.b" /> станет $_REQUEST["a_b"].
// из-за того, что PHP будет пытаться выполнить конкатенацию строк

// получение координат клика на картинке:
// <input type="image" src="image.gif" name="sub" />
// когда пользователь щелкнет где-нибудь на изображении, соответствующая форма будет передана на сервер с двумя дополнительными переменными - sub_x и sub_y

// Cookies - это механизм для хранения данных в удаленном браузере и отслеживания и идентификации таким образом вернувшихся пользователей.
?>