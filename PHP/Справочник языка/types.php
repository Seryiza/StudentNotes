<?php

// # введение
// Типы в PHP делятся на скалярные, смешанные и специальные
// Скалярные: boolean, integer, float, string
// Смешанные: array, object, callable, iterable
// Специальные: resource, NULL
// (прим.) в руководстве PHP также введены обозначения псевдотипов: mixed, number, callback (он же callable) и array|object

// проверка типа:
echo( var_dump(2 + 2) );        // int(4)
echo( var_dump("Hello!") );     // string(6) "Hello!"

echo( is_int(16) );             // True
echo( is_int(-32.32) );         // False

// для отладки можно получить тип так:
echo ( gettype(0) );            // integer (как тип)

// для изменения типа переменной можно использовать приведение к типу или использовать settype()


// # boolean
// Может быть True или False, которые регистронезависимы :p
$bool_var = True;

// конструкция:
if ($bool_var == True) { /* ... */ }

// аналогична:

if ($bool_var) { /* ... */ }

// преобразование в boolean
echo( (bool) 10.0 );        // True
echo( (boolean) "Hi!" );    // True

// в false преобразуются:
// само значение false
// integer 0
// float 0.0
// пустая строка, строка "0"
// массив без элементов
// NULL

// все остальные значения рассматриваются как true


// # целые числа
// можно указывать различные СС
$a = 1234; // десятичное число
$a = -123; // отрицательное число
$a = 0123; // восьмеричное число
$a = 0x1A; // шестнадцатеричное число
$a = 0b11111111; // двоичное число

// Размер типа зависит от платформы.
// Как правило, он 32-битный.
// Windows всегда использует 32-битный integer.
// Есть константы:
echo( PHP_INT_SIZE );
echo( PHP_INT_MAX );
echo( PHP_INT_MIN );

// если при парсинге ошибка -- то будет Parse error:
// echo( 0119 );

// при переполнении integer будет интерпретирован как float
echo( var_dump(PHP_INT_MAX + 1) );  // float(9E+18)

// оператор деления всегда возвращает float:
echo( var_dump(25/7) );             // float(3.5714)

// округлить можно напирмер так:
echo( var_dump((int) (25/7)) );     // int(3)
echo( var_dump(round(25/7)) );      // float(4) 

// приведение к integer
echo( (int) 10.5 );
echo( intval("110011", 2) );

// при преобразовании resource, будет получен уникальный номер ресурса

// false -> 0
// true -> 1
// float -> округление в сторону нуля
// NaN, Infinity -> 0
// string -> см. раздел строк
// другие типы -> неопределено


// # float
$a = 1.234; 
$b = 1.2e3; 
$c = 7E-10;

// (float) string -> см. раздел про строки
// для других типов -> будет сначала преобразование в integer, затем во float

// NAN -- неопределенный или непредставимый результат операции.
// для его сравнения следует использовать:
echo( is_nan(NAN) );        // True
echo( is_nan(1) );          // False


// # строки
// Строки -- набор символов, где символ -- это байт.
// Нет встроенный поддержки Unicode.
// В PHP 7.0.0, на 64-битных платформах нет каких-либо достижимых ограничений для длины строки, в 32-битных системах и в более ранних версиях PHP, строки не могут быть более 2 Гб

// одинарные кавычки
echo('hello!');
echo('hello! \n world');    // \n будет так и выведен
echo('hello! \' world');    // будет просто апостроф без слеша

// двойные кавычки
echo("Hello!");
echo("\n Hello");

// heredoc -- ведет себя как и двойные кавычки
// EOT -- любой идентификатор
$bar = <<<EOT
bar
EOT;

// nowdoc -- ведет себя как и одинарные кавычки
$str = <<<'EOD'
Пример текста,
занимающего несколько строк,
с помощью синтаксиса nowdoc.
EOD;

// обработка переменных
// простой синтаксис:
$some_var = 100;
echo("\n This is $some_var");
echo("\n This is ${some_var}s");

$juices = array("apple", "orange", "koolaid1" => "purple");
echo("Array elem: $juices[0]");
// аналогично можно обращаться к свойствам объекта через оператор ->

$hello = 'Hello';

// сложный синтаксис:
echo(" {$hello} ");
echo("\n Это работает: {$juices['koolaid1']}");
echo("\n var_dump: \n {${var_dump(2 + 4)}}");

// доступ к символам в строке
// получение символа:
$str = 'Hello';
echo($str[1]);
echo($str{1});

// отрицательные индексы -- с конца строки
echo("\n $str[-2]");

// пустой индекс -- фатальная ошибка
// получение длины строки:
echo(strlen($str));

// Попытка доступа к переменным других типов (исключая массивы или объекты, реализующие определенные интерфейсы) с помощью [] или {} молча вернет NULL.

// конкатенация строк -- оператор . (точка)
echo("\n Hello" . ' World');

// преобразования в строку
// можно привести к строке либо использовать strval()
// true -> "1"
// false -> ""
// int, float -> строковое представление числа
// (символ точки берется из локали)
// array -> "Array" (для более информативного вывода: print_r() и var_dump() )
// object -> используется __toString
// resource -> "Resource id #1" (для получения типа ресура -- get_resource_type() )
// NULL -> ""

// преобразование строки в число
// Если строка не содержит какой-либо из символов '.', 'e', или 'E', и значение числа помещается в пределы целых чисел (определенных PHP_INT_MAX), строка будет распознана как целое число (integer). Во всех остальных случаях она считается числом с плавающей точкой (float).

// для работы с ASCII-кодами: ord(), chr()
// примечание: строка будет закодирована тем образом, которым она записана в файле скрипта. Если не включен режим Zend Multibyte
// с Unicode следует работать осторожно: есть функции, которые работают со строкой как с однобайтным массивом и некорректно работают с UTF.

// # массивы
// на самом деле, это упорядоченное отображение (соответствие между ключ-значение)
// массив может содержать другие массивы

// определение:
$array = array(
    "foo" => "bar",
    "bar" => "foo",
);

// Начиная с PHP 5.4
$array = [
    "foo" => "bar",
    "bar" => "foo",
];

// key может быть типа string или integer
// value -- любого типа

// Ключи-строки, содержащие целое число (исключая случаи, когда число предваряется знаком +) будут преобразованы к типу integer. (можно задавать ключи как "08" -- это не 10-ричное число).
// Числа с плавающей точкой (тип float) также будут преобразованы к типу integer
// Тип bool также преобразовываются к типу integer
// Тип null будет преобразован к пустой строке
// Нельзя использовать в качестве ключей array or objects -- будет предупреждение.

// При одинаковом ключе, будет записано последнее значение (остальные будут перезаписаны)

// key вообще является необязательным: если он не указан, будет использовано предыдущее наибольшее значение ключа типа integer, увеличенное на 1
// При этом если ключа типа integer нет, то будет взят 0 (нуль).
// Причем берется не текущее максимальное, а максимальное значение за все существование массива

$array = array("foo", "bar", "hallo", "world");
var_dump($array);
/*
array(4) {
  [0]=>
  string(3) "foo"
  [1]=>
  string(3) "bar"
  [2]=>
  string(5) "hallo"
  [3]=>
  string(5) "world"
}
*/

// доступ к элементам через array[key]
// И квадратные и фигурные скобки можно взаимозаменяемо использовать для доступа к элементам массива (т.е. и $array[42] и $array{42} равнозначны).

// для добавления элемента в конец массива, можно использовать пустые скобки:
$array[] = 56;

// удаление элемента (без переиндексации):
unset($array[5]);

// удаление массива:
unset($array);

// можно переиндексировать массив используя array_values().

// всегда лучше пиши $arr['key'] вместо $arr[key]: если не будет константы key, то все нормально, но если она есть, то ее значение будет подставлено

// Преобразование в массив
// integer, float, str, bool, resource -> массив с одним элементом (индекс 0).
// (array) $scalarValue == array($scalarValue)

// object -> массив свойств (переменные-члены) этого объекта: ключами будут имена переменных-членов, с некоторыми примечательными исключениями: целочисленные свойства станут недоступны; к закрытым полям класса (private) спереди будет дописано имя класса; к защищенным полям класса (protected) спереди будет добавлен символ '*'. Эти добавленные значения с обоих сторон также имеют нулевые байты.

// NULL -> пустой массив

// изменение элементов в foreach:
foreach ($array as &$elem) {
    $elem = strtoupper($elem);
}


// # Iterables
// это псевдотип в PHP 7.1. Он принимает array или объект, реализующий интерфейс Traversable. Они могут итерироваться в foreach и быть использованы с yield from в генераторах.

// как тип параметра:
function foo(iterable $iterable) {
    foreach ($iterable as $value) {
        // ...
    } 
}

// Если переданное значение не является массивом или экземпляром класса реализующего Traversable, то будет выброшено исключение TypeError.


// # objects
// для создания нового объекта используется ключевое слово new:

class foo
{
    function do_foo()
    {
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar->do_foo();

// (object) object -> без изменений
// (object) another_type -> создается новый экземпляр stdClass.
// NULL -> пустой экземпляр
// Массивы преобразуются в object с именами полей, названными согласно ключам массива и соответствующими им значениям, за исключением числовых ключей, которые не будут доступны пока не проитерировать объект.

// scalar -> объект с полем scalar:
$obj = (object) 'ciao';
echo $obj->scalar;  // выведет 'ciao'


// # ресурс
// Resource это специальная переменная, содержащая ссылку на внешний ресурс.
// Благодаря системе подсчета ссылок, введенной в Zend Engine, определение отсутствия ссылок на ресурс происходит автоматически, после чего он освобождается сборщиком мусора.


// # NULL
// Специальное значение NULL представляет собой переменную без значения. NULL - это единственно возможное значение типа null.

// null:
// ей была присвоена константа NULL.
// ей еще не было присвоено никакого значения.
// она была удалена с помощью unset().

// null - регистронезависимая константа
// можно проверять на is_null()


// # callback-functions
// Некоторые функции, такие как call_user_func() или usort(), принимают определенные пользователем callback-функции в качестве параметра. Callback-функции могут быть как простыми функциями, так и методами объектов, включая статические методы классов.

// Помимо обычных пользовательских функций, в качестве callback-функции, можно передавать анонимные функции.

// Пример callback-функции
function my_callback_function() {
    echo 'hello world!';
}

// Простой callback
call_user_func('my_callback_function');


// Или: через замыкание
$double = function($a) {
    return $a * 2;
};

// Диапазон чисел
$numbers = range(1, 5);

// Использование замыкания в качестве callback-функции
// для удвоения каждого элемента в нашем диапазоне
$new_numbers = array_map($double, $numbers);



// # псевдотипы
// Псевдотипы - это слова, используемые в (!) документации по PHP, для обозначения типов или значений, какие могут принимать аргументы.

// mixed -- говорит о том, что параметр может принимать много (но необязательно все) типов.

// number -- говорит о том, что параметр может быть либо integer, либо float.

// callback -- использовался в этой документации до того, как был введен тип callable в PHP 5.4. Он означает в точности то же самое.

// array|object указывает, что параметр может быть как массивом array, так и объектом object.

// void в качестве типа результата означает, что возвращенное значение бесполезно. void в списке параметров означает, что функция не принимает параметров.

// $... в прототипах функции означает and so on (и так далее). Это имя переменной используется, когда функция может принимать бесконечное количество параметров.


// # манипуляции с типами
// переменные -- динамически типизированные.

/*
Допускаются следующие приведения типов:

    (int), (integer) - приведение к integer
    (bool), (boolean) - приведение к boolean
    (float), (double), (real) - приведение к float
    (string) - приведение к string
    (array) - приведение к array
    (object) - приведение к object
    (unset) - приведение к NULL (устаревшее)
*/

?>