<?php

// Любой сценарий PHP состоит из последовательности инструкций. Инструкцией может быть присваивание, вызов функции, повтор кода (цикл), сравнение, или даже инструкция, которая ничего не делает (пустой оператор). После инструкции обычно ставится точка с запятой. Кроме того, инструкции могут быть объединены в блоки заключением их в фигурные скобки. Блок инструкций также сам по себе является инструкцией. 


// -= if =-
// выражение вычисляется в булево значение. Если выражение принимает значение TRUE, PHP выполнит инструкцию, а если оно принимает значение FALSE - проигнорирует.
$a = 5;
$b = 3;
if ($a > $b) {
    echo("a больше b");
}

// Инструкции if могут быть бесконечно вложены в другие инструкции
// else-ветка:
if ($a > $b) {
  echo "a больше, чем b";
} else {
  echo "a НЕ больше, чем b";
}

// elseif-ветка:
if ($a > $b) {
    echo "a больше, чем b";
} elseif ($a == $b) {
    echo "a равен b";
} else {
    echo "a меньше, чем b";
}

// (elseif и else if будут равнозначны только при использовании фигурных скобок, как в примерах выше. Если используются двоеточие для определения условий if/elseif, Вы не должны разделять else if в два слова, иначе это вызовет фатальную ошибку в PHP.)


// -= Альтернативный синтаксис =-
// PHP предлагает альтернативный синтаксис для некоторых его управляющих структур, а именно: if, while, for, foreach и switch. В каждом случае основной формой альтернативного синтаксиса является изменение открывающей фигурной скобки на двоеточие (:), а закрывающей скобки на endif;, endwhile;, endfor;, endforeach; или endswitch; соответственно.
?>

<?php if ($a == 5): ?>
A равно 5
<?php endif; ?>

<?php

// аналогично:
if ($a == 5):
    echo "a равно 5";
    echo "...";
elseif ($a == 6):
    echo "a равно 6";
    echo "!!!";
else:
    echo "a не равно ни 5 ни 6";
endif;

// прим.: Смешивание синтаксиса в одном и том же блоке управления не поддерживается.

// (oh)
// Любой вывод (включая пробельные символы) между выражением switch и первым case приведут к синтаксической ошибке. Например этот код не будет работать:
/*
<?php switch ($foo): ?>
    <?php case 1: ?>
    ...
<?php endswitch ?>
*/

// а это будет:
/*
<?php switch ($foo): ?>
<?php case 1: ?>
    ...
<?php endswitch ?>
*/

// -= while =-
$i = 1;
while ($i <= 10) {
    echo $i++;
}


// -= do-while =-
$i = 0;
do {
    echo $i;
} while ($i > 0);


// -= for =-
for ($i = 1; $i <= 10; $i++) {
    echo $i;
}

// -= foreach =-
// Конструкция foreach предоставляет простой способ перебора массивов. Foreach работает только с массивами и объектами, и будет генерировать ошибку при попытке использования с переменными других типов или неинициализированными переменными.

/*
Существует два вида синтаксиса:

foreach (array_expression as $value)
    statement

foreach (array_expression as $key => $value)
    statement
*/

// Для того, чтобы напрямую изменять элементы массива внутри цикла, переменной $value должен предшествовать знак &. В этом случае значение будет присвоено по ссылке.
$arr = array(1, 2, 3, 4);
foreach ($arr as &$value) {
    $value = $value * 2;
}
// массив $arr сейчас таков: array(2, 4, 6, 8)
unset($value); // разорвать ссылку на последний элемент

// Ссылка $value на последний элемент массива останется после окончания цикла foreach. Рекомендуется уничтожать ее с помощью unset().

// В PHP 5.5 была добавлена возможность обхода массива массивов с распаковкой вложенного массива в переменные цикла, передав list() в качестве значения.
$array = [
    [1, 2],
    [3, 4],
];

foreach ($array as list($a, $b)) {
    // $a содержит первый элемент вложенного массива,
    // а $b содержит второй элемент.
    echo "A: $a; B: $b\n";
}

// (Можно передавать меньшее количество элементов в list(), чем находится во вложенном массиве, в этом случае оставшиеся значения массива будут проигнорированы)
// Если передать в list() больше, чем имеет массив - будет ошибка


// -= break =-
// break прерывает выполнение текущей структуры for, foreach, while, do-while или switch.
// break принимает необязательный числовой аргумент, который сообщает ему выполнение какого количества вложенных структур необходимо прервать. Значение по умолчанию 1, только ближайшая структура будет прервана (передается через пробел).


// -= continue =-
// continue используется внутри циклических структур для пропуска оставшейся части текущей итерации цикла и, при соблюдении условий, начала следующей итерации.

// аналогично, continue принимает необязательный числовой аргумент, который указывает на скольких уровнях вложенных циклов будет пропущена оставшаяся часть итерации.


// -= switch =-
// конструкция switch/case использует неточное сравнение (==)
// прим.  В PHP, структура switch считается циклической, и внутри нее может использоваться continue (аналогична break).

// Важно понять, как оператор switch выполняется, чтобы избежать ошибок. Оператор switch исполняет строчка за строчкой (на самом деле выражение за выражением). В начале никакой код не исполняется. Только в случае нахождения оператора case, значение которого совпадает со значением выражения в операторе switch, PHP начинает исполнять операторы. PHP продолжает исполнять операторы до конца блока switch либо до тех пор, пока не встретит оператор break. Если вы не напишете оператор break в конце секции case, PHP будет продолжать исполнять команды следующей секции case.

// Список операторов для исполнения в секции case также может быть пустым, что просто передает управление списку операторов в следующей секции case.
switch ($i) {
case 0:
case 1:
case 2:
    echo "i меньше чем 3, но неотрицательно";
    break;
case 3:
    echo "i равно 3";
}

// Специальный вид конструкции case -- default.
switch ($i) {
    case 0:
        echo "i равно 0";
        break;
    case 1:
        echo "i равно 1";
        break;
    case 2:
        echo "i равно 2";
        break;
    default:
       echo "i не равно 0, 1 или 2";
}


// -= declare =-
// Конструкция declare используется для установки директив исполнения для блока кода.
// Секция directive позволяет установить поведение блока declare. В настоящее время распознаются только три директивы: директива ticks, директива encoding и директива strict_types

// директива обрабатывается при компиляции файла.
// выполняется одинаково:

// можно так:
declare(ticks=1) {
    // прочие действия
}

// или так:
declare(ticks=1);
// прочие действия

/*
Тик - это событие, которое случается каждые N низкоуровневых операций, выполненных парсером внутри блока declare. Значение N задается, используя ticks=N внутри секции directive блока declare.

Не все выражения подсчитываются. Обычно, условные выражения и выражения аргументов не подсчитываются.

Событие (или несколько событий), которое возникает на каждом тике определяется, используя register_tick_function(). Смотрите пример ниже для дополнительной информации. Имейте в виду, что для одного тика может возникать несколько событий.
*/

// Пример:
declare(ticks=1);

// Функция, исполняемая при каждом тике
function tick_handler()
{
    echo "tick_handler() выполнено\n";
}

register_tick_function('tick_handler');

$a = 1;

if ($a > 0) {
    $a += 2;
    print($a);
}

// Кодировка:
// declare(encoding='ISO-8859-1');


// -= return =-
// return возвращает управление программой модулю, из которого была вызвана функция. Выполнение программы продолжается с инструкции, следующей за местом вызова.
// return также завершит выполнение выражения eval() или всего файла скрипта.

// -= require =-
// require идентично include за исключением того, что при ошибке оно также выдаст фатальную ошибку уровня E_COMPILE_ERROR. Другими словами, она остановит выполнение скрипта, тогда как include только выдала бы предупреждение E_WARNING, которое позволило бы скрипту продолжить выполнение.


// -= include =-
// Выражение include включает и выполняет указанный файл.
// Документация ниже также относится к выражению require.
// Файлы включаются исходя из пути указанного файла, или, если путь не указан, используется путь, указанный в директиве include_path. Если файл не найден в include_path, include попытается проверить директорию, в которой находится текущий включающий скрипт и текущую рабочую директорию перед тем, как выдать ошибку. Конструкция include выдаст warning, если не сможет найти файл; поведение отлично от require, который выдаст фатальную ошибку.

// Если путь указан — не важно, абсолютный (начинающийся с буквы диска или с \ в Windows или с / в Unix/Linux системах) или относительно текущей директории (начинающийся с . или ..) — директива include_path будет проигнорирована в любом случае.

// Когда файл включается, его код наследует ту же область видимости переменых, что и строка, на которой произошло включение.

/*
vars.php
<?php

$color = 'green';
$fruit = 'apple';

?>

test.php
<?php

echo "A $color $fruit"; // A

include 'vars.php';

echo "A $color $fruit"; // A green apple

?>
*/


// -= require_once, include_once =-
// Выражение require_once идентично require за исключением того, что PHP проверит, включался ли уже данный файл, и, если да, не будет включать его еще раз.

// Выражение include_once включает и выполняет указанный файл во время выполнения скрипта. Его поведение идентично выражению include, с той лишь разницей, что если код из файла уже один раз был включен, он не будет включен и выполнен повторно и вернёт TRUE. Как видно из имени, он включит файл только один раз (include once).

// include_once может использоваться в тех случаях, когда один и тот же файл может быть включен и выполнен более одного раза во время выполнения скрипта, в данном случае это поможет избежать проблем с переопределением функций, переменных и т.д.


// -= goto =-
goto a;
echo 'Foo';
 
a:
echo 'Bar';
?>